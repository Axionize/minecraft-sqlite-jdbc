name: Auto‑Bump SQLite‑JDBC

on:
  schedule:
    - cron: '0 5 * * *'
  workflow_dispatch:
    inputs:
      should_bump:
        description: 'Run Bump Process? (Select "no" to just trigger a build)'
        type: boolean
        required: true
        default: true
      version:
        description: 'Manual sqlite-jdbc version override (e.g., 3.51.0.0)'
        required: false
        default: ''

permissions:
  contents: write
  pull-requests: write

jobs:
  bump:
    runs-on: ubuntu-latest

    env:
      # --- CONFIGURABLE VIA REPOSITORY VARIABLES ---
      GIT_AUTHOR_NAME:  "${{ vars.GIT_AUTHOR_NAME || 'Axionize' }}"
      GIT_AUTHOR_EMAIL: "${{ vars.GIT_AUTHOR_EMAIL || '154778082+Axionize@users.noreply.github.com' }}"
      BOT_NAME:         "${{ vars.BOT_NAME || 'Axionize' }}"
      BOT_EMAIL:        "${{ vars.BOT_EMAIL || 'Axionize+bot@example.com' }}"

    steps:
      # 1) Setup dynamic author and token based on PAT availability
      - name: Setup Context
        id: setup_context
        run: |
          if [[ -n "${{ secrets.AUTOMATION_PAT }}" ]]; then
            echo "PAT secret found. Commits will be attributed to '${{ env.GIT_AUTHOR_NAME }}'."
            echo "token=${{ secrets.AUTOMATION_PAT }}" >> $GITHUB_OUTPUT
            echo "author_string=${{ env.GIT_AUTHOR_NAME }} <${{ env.GIT_AUTHOR_EMAIL }}>" >> $GITHUB_OUTPUT
          else
            echo "No PAT secret found. Falling back to bot identity '${{ env.BOT_NAME }}'."
            echo "token=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
            echo "author_string=${{ env.BOT_NAME }} <${{ env.BOT_EMAIL }}>" >> $GITHUB_OUTPUT
          fi

      # 2) Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ steps.setup_context.outputs.token }}

      # 3) Core Logic: Decide if we should bump, dispatch, or do nothing
      - name: Determine Action
        id: decision
        run: |
          SHOULD_BUMP=false
          SHOULD_DISPATCH=false
          NEW_VER=""
          CHANGELOG_MSG=""

          if [[ "${{ github.event.inputs.should_bump }}" == "false" ]]; then
            # Manual trigger to just re-build, no bump
            echo "Manual trigger to re-build. Bumping process will be skipped."
            SHOULD_DISPATCH=true
            NEW_VER=$(grep '^library_version=' gradle.properties | cut -d'=' -f2)
            CHANGELOG_MSG="Manual re-build of version ${NEW_VER}."
          else
            # Standard bump process (scheduled or manual with bump=true)
            echo "Starting standard bump process..."
            if [[ -n "${{ github.event.inputs.version }}" ]]; then
              echo "Using manually specified version: ${{ github.event.inputs.version }}"
              NEW_VER="${{ github.event.inputs.version }}"
            else
              # --- FIX: Switched to the reliable maven-metadata.xml ---
              echo "Fetching latest version from Maven Central's metadata..."
              # This URL is the direct source of truth and updates instantly.
              METADATA_URL='https://repo1.maven.org/maven2/org/xerial/sqlite-jdbc/maven-metadata.xml'
              NEW_VER=$(curl -s "$METADATA_URL" | grep '<latest>' | sed -E 's/.*<latest>(.+)<\/latest>.*/\1/')
            fi

            if [[ -z "$NEW_VER" ]]; then
              echo "::error::Could not determine a target version. Aborting."
              exit 1
            fi

            CURRENT_VER=$(grep '^library_version=' gradle.properties | cut -d'=' -f2 || echo "NOT_FOUND")
            echo "Current version: $CURRENT_VER | Target version: $NEW_VER"

            if [[ "$NEW_VER" != "$CURRENT_VER" ]]; then
              echo "Version differs. Proceeding with bump and dispatch."
              SHOULD_BUMP=true
              SHOULD_DISPATCH=true
              CHANGELOG_MSG="Automated bump to version **${NEW_VER}**."
            else
              echo "Version is already up-to-date. No action needed."
            fi
          fi

          echo "should_bump=$SHOULD_BUMP" >> "$GITHUB_OUTPUT"
          echo "should_dispatch=$SHOULD_DISPATCH" >> "$GITHUB_OUTPUT"
          echo "new_version=$NEW_VER" >> "$GITHUB_OUTPUT"
          echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
          echo "$CHANGELOG_MSG" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          echo "NEW_VER=$NEW_VER" >> "$GITHUB_ENV" # For later steps

      # 4) Bump version & release_date in gradle.properties
      - name: Bump version & release date
        if: steps.decision.outputs.should_bump == 'true'
        run: |
          set -e
          TODAY=$(date -u +%F)
          echo "Updating gradle.properties to version ${{ env.NEW_VER }} and date $TODAY"
          sed -i "s/^library_version=.*/library_version=${{ env.NEW_VER }}/" gradle.properties
          if grep -q '^release_date=' gradle.properties; then
            sed -i "s/^release_date=.*/release_date=${TODAY}/" gradle.properties
          else
            echo "release_date=${TODAY}" >> gradle.properties
          fi

      # 5) Create Pull Request
      - name: Create Pull Request
        id: create-pr
        if: steps.decision.outputs.should_bump == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ steps.setup_context.outputs.token }}
          author: ${{ steps.setup_context.outputs.author_string }}
          committer: "${{ env.BOT_NAME }} <${{ env.BOT_EMAIL }}>"
          branch: "bump/sqlite-${{ env.NEW_VER }}"
          add-paths: gradle.properties
          commit-message: "chore: bump sqlite-jdbc to ${{ env.NEW_VER }}"
          title: "chore: bump sqlite-jdbc to ${{ env.NEW_VER }}"
          body: ${{ steps.decision.outputs.changelog }}
          delete-branch: true

      # 6) Enable PR Auto-Merge
      - name: Enable PR auto-merge
        if: steps.create-pr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ steps.setup_context.outputs.token }}
        run: |
          gh pr merge --squash --auto "${{ steps.create-pr.outputs.pull-request-number }}"

      # 7) Trigger Release Workflow
      - name: Trigger Nightly Release via Dispatch
        if: steps.decision.outputs.should_dispatch == 'true'
        env:
          GH_TOKEN: ${{ steps.setup_context.outputs.token }}
        run: |
          set -e
          JSON_PAYLOAD=$(jq -n \
            --arg ver "${{ steps.decision.outputs.new_version }}" \
            --arg changelog "${{ steps.decision.outputs.changelog }}" \
            --arg ref "refs/heads/bump/sqlite-${{ steps.decision.outputs.new_version }}" \
            '{event_type: "sqlite_jdbc_bumped", client_payload: {version: $ver, changelog: $changelog, ref: $ref}}')

          echo "Sending dispatch with payload: $JSON_PAYLOAD"
          echo "$JSON_PAYLOAD" | gh api \
            --method POST \
            -H "Accept: application/vnd.github.v3+json" \
            /repos/${{ github.repository }}/dispatches \
            --input -
          echo "Dispatch event sent."